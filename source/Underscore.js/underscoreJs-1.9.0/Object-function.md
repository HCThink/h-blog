## Object function

> 对象操作

```javascript
// Keys in IE < 9 that won't be iterated by `for key in ...` and thus missed.
var hasEnumBug = !{
    toString: null
}.propertyIsEnumerable('toString');
var nonEnumerableProps = [
    'valueOf',
    'isPrototypeOf',
    'toString',
    'propertyIsEnumerable',
    'hasOwnProperty',
    'toLocaleString'
];

var collectNonEnumProps = function(obj, keys) {
    var nonEnumIdx = nonEnumerableProps.length;
    var constructor = obj.constructor;
    var proto = _.isFunction(constructor) && constructor.prototype || ObjProto;

    // Constructor is a special case.
    var prop = 'constructor';
    if (_.has(obj, prop) && !_.contains(keys, prop))
        keys.push(prop);

    while (nonEnumIdx--) {
        prop = nonEnumerableProps[nonEnumIdx];
        if (prop in obj && obj[prop] !== proto[prop] && !_.contains(keys, prop)) {
            keys.push(prop);
        }
    }
};

// Retrieve the names of an object's own properties.
// Delegates to **ECMAScript 5**'s native `Object.keys`
_.keys = function(obj) {
    if (!_.isObject(obj))
        return [];
    if (nativeKeys)
        return nativeKeys(obj);
    var keys = [];
    for (var key in obj)
        if (_.has(obj, key))
            keys.push(key);
// Ahem, IE < 9.
    if (hasEnumBug)
        collectNonEnumProps(obj, keys);
    return keys;
};

// Retrieve all the property names of an object.
_.allKeys = function(obj) {
    if (!_.isObject(obj))
        return [];
    var keys = [];
    for (var key in obj)
        keys.push(key);

    // Ahem, IE < 9.
    if (hasEnumBug)
        collectNonEnumProps(obj, keys);
    return keys;
};

// Retrieve the values of an object's properties.
_.values = function(obj) {
    var keys = _.keys(obj);
    var length = keys.length;
    var values = Array(length);
    for (var i = 0; i < length; i++) {
        values[i] = obj[keys[i]];
    }
    return values;
};

// Returns the results of applying the iteratee to each element of the object
// In contrast to _.map it returns an object
_.mapObject = function(obj, iteratee, context) {
    iteratee = cb(iteratee, context);
    var keys = _.keys(obj),
        length = keys.length,
        results = {};
    for (var index = 0; index < length; index++) {
        var currentKey = keys[index];
        results[currentKey] = iteratee(obj[currentKey], currentKey, obj);
    }
    return results;
};

// Convert an object into a list of `[key, value]` pairs.
_.pairs = function(obj) {
    var keys = _.keys(obj);
    var length = keys.length;
    var pairs = Array(length);
    for (var i = 0; i < length; i++) {
        pairs[i] = [
            keys[i],
            obj[keys[i]]
        ];
    }
    return pairs;
};

// Invert the keys and values of an object. The values must be serializable.
_.invert = function(obj) {
    var result = {};
    var keys = _.keys(obj);
    for (var i = 0, length = keys.length; i < length; i++) {
        result[obj[keys[i]]] = keys[i];
    }
    return result;
};

// Return a sorted list of the function names available on the object.
// Aliased as `methods`
/**
 * functions 拿到一个对象的所有函数名. 并返回这个有序集合.
 * 主要用于批量 copy _ 上面声明的'静态'操作到 _ 的实例上
 */
_.functions = _.methods = function(obj) {
    var names = [];
    for (var key in obj) {
        if (_.isFunction(obj[key]))
            names.push(key);
        }
    return names.sort();
};

// An internal function for creating assigner functions.
var createAssigner = function(keysFunc, undefinedOnly) {
    return function(obj) {
        var length = arguments.length;
        if (length < 2 || obj == null)
            return obj;
        for (var index = 1; index < length; index++) {
            var source = arguments[index],
                keys = keysFunc(source),
                l = keys.length;
            for (var i = 0; i < l; i++) {
                var key = keys[i];
                if (!undefinedOnly || obj[key] === void 0)
                    obj[key] = source[key];
                }
            }
        return obj;
    };
};

// Extend a given object with all the properties in passed-in object(s).
_.extend = createAssigner(_.allKeys);

// Assigns a given object with all the own properties in the passed-in object(s)
// (https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Object/assign)
_.extendOwn = _.assign = createAssigner(_.keys);

// Returns the first key on an object that passes a predicate test
_.findKey = function(obj, predicate, context) {
    predicate = cb(predicate, context);
    var keys = _.keys(obj),
        key;
    for (var i = 0, length = keys.length; i < length; i++) {
        key = keys[i];
        if (predicate(obj[key], key, obj))
            return key;
        }
    };

// Internal pick helper function to determine if `obj` has key `key`.
var keyInObj = function(value, key, obj) {
    return key in obj;
};

// Return a copy of the object only containing the whitelisted properties.
_.pick = restArgs(function(obj, keys) {
    var result = {},
        iteratee = keys[0];
    if (obj == null)
        return result;
    if (_.isFunction(iteratee)) {
        if (keys.length > 1)
            iteratee = optimizeCb(iteratee, keys[1]);
        keys = _.allKeys(obj);
    } else {
        iteratee = keyInObj;
        keys = flatten(keys, false, false);
        obj = Object(obj);
    }
    for (var i = 0, length = keys.length; i < length; i++) {
        var key = keys[i];
        var value = obj[key];
        if (iteratee(value, key, obj))
            result[key] = value;
        }
    return result;
});

// Return a copy of the object without the blacklisted properties.
_.omit = restArgs(function(obj, keys) {
    var iteratee = keys[0],
        context;
    if (_.isFunction(iteratee)) {
        iteratee = _.negate(iteratee);
        if (keys.length > 1)
            context = keys[1];
        }
    else {
        keys = _.map(flatten(keys, false, false), String);
        iteratee = function(value, key) {
            return !_.contains(keys, key);
        };
    }
    return _.pick(obj, iteratee, context);
});

// Fill in a given object with default properties.
_.defaults = createAssigner(_.allKeys, true);

// Creates an object that inherits from the given prototype object.
// If additional properties are provided then they will be added to the
// created object.
_.create = function(prototype, props) {
    var result = baseCreate(prototype);
    if (props)
        _.extendOwn(result, props);
    return result;
};

// Create a (shallow-cloned) duplicate of an object.
_.clone = function(obj) {
    if (!_.isObject(obj))
        return obj;
    return _.isArray(obj)
        ? obj.slice()
        : _.extend({}, obj);
};

// Invokes interceptor with the obj, and then returns obj.
// The primary purpose of this method is to "tap into" a method chain, in
// order to perform operations on intermediate results within the chain.
_.tap = function(obj, interceptor) {
    interceptor(obj);
    return obj;
};

// Returns whether an object has a given set of `key:value` pairs.
_.isMatch = function(object, attrs) {
    var keys = _.keys(attrs),
        length = keys.length;
    if (object == null)
        return !length;
    var obj = Object(object);
    for (var i = 0; i < length; i++) {
        var key = keys[i];
        if (attrs[key] !== obj[key] || !(key in obj))
            return false;
        }
    return true;
};

// Internal recursive comparison function for `isEqual`.
var eq,
    deepEq;
eq = function(a, b, aStack, bStack) {
    // Identical objects are equal. `0 === -0`, but they aren't identical.
    // See the [Harmony `egal` proposal](http://wiki.ecmascript.org/doku.php?id=harmony:egal).
    if (a === b)
        return a !== 0 || 1 / a === 1 / b;

    // A strict comparison is necessary because `null == undefined`.
    if (a == null || b == null)
        return a === b;

    // `NaN`s are equivalent, but non-reflexive.
    if (a !== a)
        return b !== b;

    // Exhaust primitive checks
    var type = typeof a;
    if (type !== 'function' && type !== 'object' && typeof b !== 'object')
        return false;
    return deepEq(a, b, aStack, bStack);
};

// Internal recursive comparison function for `isEqual`.
deepEq = function(a, b, aStack, bStack) {
    // Unwrap any wrapped objects.
    if (a instanceof _)
        a = a._wrapped;
    if (b instanceof _)
        b = b._wrapped;

    // Compare `[[Class]]` names.
    var className = toString.call(a);
    if (className !== toString.call(b))
        return false;
    switch (className) {
            // Strings, numbers, regular expressions, dates, and booleans are compared by value.
        case '[object RegExp]':
            // RegExps are coerced to strings for comparison (Note: '' + /a/i === '/a/i')
        case '[object String]':
            // Primitives and their corresponding object wrappers are equivalent; thus, `"5"` is
            // equivalent to `new String("5")`.
            return '' + a === '' + b;
        case '[object Number]':
            // `NaN`s are equivalent, but non-reflexive.
            // Object(NaN) is equivalent to NaN
            if (+ a !== + a)
                return + b !== + b;

            // An `egal` comparison is performed for other numeric values.
            return + a === 0
                ? 1 / + a === 1 / b
                : + a === + b;
        case '[object Date]':
        case '[object Boolean]':
            // Coerce dates and booleans to numeric primitive values. Dates are compared by their
            // millisecond representations. Note that invalid dates with millisecond representations
            // of `NaN` are not equivalent.
            return + a === + b;
    }

    var areArrays = className === '[object Array]';
    if (!areArrays) {
        if (typeof a != 'object' || typeof b != 'object')
            return false;

        // Objects with different constructors are not equivalent, but `Object`s or `Array`s
        // from different frames are.
        var aCtor = a.constructor,
            bCtor = b.constructor;
        if (aCtor !== bCtor && !(_.isFunction(aCtor) && aCtor instanceof aCtor && _.isFunction(bCtor) && bCtor instanceof bCtor) && ('constructor' in a && 'constructor' in b)) {
            return false;
        }
    }
    // Assume equality for cyclic structures. The algorithm for detecting cyclic
    // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.

    // Initializing stack of traversed objects.
    // It's done here since we only need them for objects and arrays comparison.
    aStack = aStack || [];
    bStack = bStack || [];
    var length = aStack.length;
    while (length--) {
        // Linear search. Performance is inversely proportional to the number of
        // unique nested structures.
        if (aStack[length] === a)
            return bStack[length] === b;
        }

    // Add the first object to the stack of traversed objects.
    aStack.push(a);
    bStack.push(b);

    // Recursively compare objects and arrays.
    if (areArrays) {
        // Compare array lengths to determine if a deep comparison is necessary.
        length = a.length;
        if (length !== b.length)
            return false;

        // Deep compare the contents, ignoring non-numeric properties.
        while (length--) {
            if (!eq(a[length], b[length], aStack, bStack))
                return false;
            }
        } else {
        // Deep compare objects.
        var keys = _.keys(a),
            key;
        length = keys.length;
        // Ensure that both objects contain the same number of properties before comparing deep equality.
        if (_.keys(b).length !== length)
            return false;
        while (length--) {
            // Deep compare each member
            key = keys[length];
            if (!(_.has(b, key) && eq(a[key], b[key], aStack, bStack)))
                return false;
            }
        }
    // Remove the first object from the stack of traversed objects.
    aStack.pop();
    bStack.pop();
    return true;
};

// Perform a deep comparison to check if two objects are equal.
_.isEqual = function(a, b) {
    return eq(a, b);
};

// Is a given array, string, or object empty?
// An "empty" object has no enumerable own-properties.
_.isEmpty = function(obj) {
    if (obj == null)
        return true;
    if (isArrayLike(obj) && (_.isArray(obj) || _.isString(obj) || _.isArguments(obj)))
        return obj.length === 0;
    return _.keys(obj).length === 0;
};

// Is a given value a DOM element?
_.isElement = function(obj) {
    return !!(obj && obj.nodeType === 1);
};

// Is a given value an array?
// Delegates to ECMA5's native Array.isArray
_.isArray = nativeIsArray || function(obj) {
    return toString.call(obj) === '[object Array]';
};

// Is a given variable an object?
_.isObject = function(obj) {
    var type = typeof obj;
    return type === 'function' || type === 'object' && !!obj;
};

// Add some isType methods: isArguments, isFunction, isString, isNumber, isDate, isRegExp, isError.
_.each([
    'Arguments',
    'Function',
    'String',
    'Number',
    'Date',
    'RegExp',
    'Error'
], function(name) {
    _['is' + name] = function(obj) {
        return toString.call(obj) === '[object ' + name + ']';
    };
});

// Define a fallback version of the method in browsers (ahem, IE < 9), where
// there isn't any inspectable "Arguments" type.
if (!_.isArguments(arguments)) {
    _.isArguments = function(obj) {
        return _.has(obj, 'callee');
    };
}

// Optimize `isFunction` if appropriate. Work around some typeof bugs in old v8,
// IE 11 (#1621), and in Safari 8 (#1929).
if (typeof /./ != 'function' && typeof Int8Array != 'object') {
    _.isFunction = function(obj) {
        return typeof obj == 'function' || false;
    };
}

// Is a given object a finite number?
_.isFinite = function(obj) {
    return isFinite(obj) && !isNaN(parseFloat(obj));
};

// Is the given value `NaN`? (NaN is the only number which does not equal itself).
_.isNaN = function(obj) {
    return _.isNumber(obj) && obj !== + obj;
};

// Is a given value a boolean?
_.isBoolean = function(obj) {
    return obj === true || obj === false || toString.call(obj) === '[object Boolean]';
};

// Is a given value equal to null?
_.isNull = function(obj) {
    return obj === null;
};

// Is a given variable undefined?
_.isUndefined = function(obj) {
    return obj === void 0;
};

// Shortcut function for checking if an object has a given property directly
// on itself (in other words, not on a prototype).
_.has = function(obj, key) {
    return obj != null && hasOwnProperty.call(obj, key);
};
```
