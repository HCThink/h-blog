/**
 * 给定一个非负整数 num， 反复将各个位上的数字相加， 直到结果为一位数。

 示例:

     输入: 38
 输出: 2
 解释: 各位相加的过程为： 3 + 8 = 11, 1 + 1 = 2。 由于 2 是一位数， 所以返回 2。
 进阶:
     你可以不使用循环或者递归， 且在 O(1) 时间复杂度内解决这个问题吗？
 */

/**
 * @param {number} num
 * @return {number}
 * 此题需要数学知识，反正我是一脸懵逼。
 *
 * https://www.zhihu.com/question/30972581

 首先： 12345 = 1 * 9999 + 2 * 999 + 3 * 99 + 4 * 9 +
     5 + (1 + 2 + 3 + 4 + 5) 只要证明： 12345 % 9 = (1 + 2 + 3 + 4 + 5) % 9 就能往下递推了。 那么， 我们已知： m % 9 = a;
 n % 9 = b 即 m = 9 * x +
     a;
 n = 9 * y + b； 可推出(m + n) % 9 = a + b = m % 9 + n % 9；[1 * 9999 + 2 * 999 + 3 * 99 + 4 * 9 + (1 +
         2 + 3 + 4 + 5)] % 9 = (1 * 9999) % 9 + (2 * 999) % 9 + (3 * 99) % 9 + (4 * 9) %
     9 + (1 + 2 + 3 + 4 + 5) % 9 = 0 + 0 + 0 + 0 + (1 + 2 + 3 + 4 + 5) % 9 = (1 + 2 +
         3 + 4 + 5) % 9。 证明完成： 12345 % 9 = (1 + 2 + 3 + 4 + 5) % 9;
 因为题中最后一个数恰好是小于10， 与取mod 9 结束也一致， 所以：(12345) % 9 = (1 + 2 + 3 + 4 + 5) % 9 = 12 %
     9 = (1 + 2) % 9 = 3 % 9 = 3。
 */
var addDigits = function (num) {
    return (num - 1) % 9 + 1;
};


const re = addDigits(1);
console.log(re);


/**
 * leecode 耗时最少解法
 * @param {number} num
 * @return {number}
 */
var addDigits = function (num) {
    if (num == 0) {
        return 0;
    }
    if (num % 9 == 0) {
        return 9;
    } else {
        return num % 9;
    }
};
